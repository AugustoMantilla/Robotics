{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Documentaci\u00f3n del Proyecto","text":"<p>Bienvenido \ud83d\udc4b Esta es una plantilla basada en MkDocs + Material for MkDocs para cursos y proyectos.</p>"},{"location":"#empezar-rapido-3-pasos","title":"Empezar r\u00e1pido (3 pasos)","text":"<ol> <li>Edita el nombre del sitio en <code>mkdocs.yml</code>:    ```yaml    site_name: Documentaci\u00f3n del Curso    theme:      name: material</li> </ol>"},{"location":"comandos/","title":"Encabezados","text":"<pre><code># T\u00edtulo H1\n## T\u00edtulo H2\n### T\u00edtulo H3\n</code></pre>"},{"location":"comandos/#titulo-h1","title":"T\u00edtulo H1","text":""},{"location":"comandos/#titulo-h2","title":"T\u00edtulo H2","text":""},{"location":"comandos/#titulo-h3","title":"T\u00edtulo H3","text":""},{"location":"comandos/#enfasis-y-codigo-en-linea","title":"\u00c9nfasis y c\u00f3digo en l\u00ednea","text":"<pre><code>**negritas**, *cursivas*, ~~tachado~~, `c\u00f3digo en l\u00ednea`\n</code></pre> <p>negritas, cursivas, ~~tachado~~, <code>c\u00f3digo en l\u00ednea</code></p>"},{"location":"comandos/#citas-blockquote","title":"Citas (blockquote)","text":"<pre><code>&gt; Esta es una cita destacada.\n&gt; Puede tener m\u00faltiples l\u00edneas.\n</code></pre> <p>Esta es una cita destacada. Puede tener m\u00faltiples l\u00edneas.</p>"},{"location":"comandos/#enlaces","title":"Enlaces","text":"<pre><code>[Enlace directo](https://www.iberopuebla.mx/)\n\n[Texto del enlace de referencia][doc-ref]\n\n[doc-ref]: https://www.iberopuebla.mx//docs \"T\u00edtulo opcional\"\n</code></pre> <p>Enlace directo</p> <p>Texto del enlace de referencia</p>"},{"location":"comandos/#listas-vinetas-numeradas-y-de-tareas","title":"Listas: vi\u00f1etas, numeradas y de tareas","text":"<pre><code>- Item A\n    * Subitem A.1\n    * Subitem A.2\n- Item B\n    - Subitem B.1\n    - Subitem B.2\n\n1.  Paso 1\n    1.  Paso 1.1\n    2.  Paso 1.2\n        1.  Paso 1.2.1\n        2.  Paso 1.2.2\n\n- [x] Hecho\n- [ ] Pendiente\n</code></pre> <ul> <li>Item A<ul> <li>Subitem A.1</li> <li>Subitem A.2</li> </ul> </li> <li>Item B<ul> <li>Subitem B.1</li> <li>Subitem B.2</li> </ul> </li> </ul> <ol> <li> <p>Paso 1</p> <ol> <li>Paso 1.1</li> <li>Paso 1.2<ol> <li>Paso 1.2.1</li> <li>Paso 1.2.2</li> </ol> </li> </ol> </li> <li> <p> Hecho</p> </li> <li> Pendiente</li> </ol>"},{"location":"comandos/#tablas","title":"Tablas","text":"<pre><code>| Componente | Cant. | Nota        |\n|-----------:|:-----:|-------------|\n| Sensor X   | 2     | I2C         |\n| MCU Y      | 1     | WiFi/BLE    |\n</code></pre> Componente Cant. Nota Sensor X 2 I2C MCU Y 1 WiFi/BLE"},{"location":"comandos/#imagenes","title":"Im\u00e1genes","text":"<pre><code>![Diagrama del sistema](recursos/imgs/ibero.jpeg)\n\n&lt;!-- Control de tama\u00f1o usando HTML (cuando se requiera) --&gt;\n&lt;img src=\"../recursos/imgs/ibero.jpeg\" alt=\"Diagrama del sistema\" width=\"420\"&gt;\n</code></pre>"},{"location":"comandos/#pdfs-enlace-y-embebido","title":"PDFs (enlace y embebido)","text":"<pre><code>[Descargar especificaci\u00f3n (PDF)](recursos/archivos/Calendario.pdf)\n\n&lt;!-- Embed (requiere navegador compatible) --&gt;\n&lt;object data=\"recursos/archivos/Calendario.pdf\" type=\"application/pdf\" width=\"100%\" height=\"600\"&gt;\n  &lt;p&gt;No se pudo mostrar el PDF. &lt;a href=\"../recursos/archivos/Calendario.pdf\"&gt;Descargar&lt;/a&gt;&lt;/p&gt;\n&lt;/object&gt;\n</code></pre> <p>Descargar especificaci\u00f3n (PDF)</p>"},{"location":"comandos/#admonitions-material","title":"Admonitions (Material)","text":"<pre><code>!!! note \"Nota\"\n    Esto es una nota informativa.\n\n!!! tip \"Sugerencia\"\n    Un consejo breve para el usuario.\n\n!!! warning \"Advertencia\"\n    Precauciones o riesgos a considerar.\n\n??? info \"M\u00e1s informaci\u00f3n (colapsable)\"\n    Contenido adicional que se puede expandir.\n</code></pre> <p>Nota</p> <p>Esto es una nota informativa.</p> <p>Sugerencia</p> <p>Un consejo breve para el usuario.</p> <p>Advertencia</p> <p>Precauciones o riesgos a considerar.</p> M\u00e1s informaci\u00f3n (colapsable) <p>Contenido adicional que se puede expandir.</p>"},{"location":"comandos/#codigo-con-resaltado","title":"C\u00f3digo con resaltado","text":"<p><pre><code>```python\ndef medir(canal: int) -&gt; dict:\n    # Simulaci\u00f3n de lectura\n    return {\"canal\": canal, \"valor\": 523, \"unidad\": \"mV\"}\n\nprint(medir(1))\n</code></pre> <pre><code>```python\ndef medir(canal: int) -&gt; dict:\n    # Simulaci\u00f3n de lectura\n    return {\"canal\": canal, \"valor\": 523, \"unidad\": \"mV\"}\n\nprint(medir(1))\n</code></pre></p>"},{"location":"comandos/#separador-horizontal","title":"Separador horizontal","text":"<pre><code>---\n</code></pre>"},{"location":"comandos/#listas-anidadas-con-codigo-y-notas","title":"Listas anidadas con c\u00f3digo y notas","text":"<pre><code>- **M\u00f3dulo A**\n  - Funci\u00f3n: `procesar()`\n  - Entrada:\n    - `signal` (float)\n    - `freq` (Hz)\n  - Salida:\n    - JSON con `valor`, `unidad`\n  - !!! note\n        Documenta rangos v\u00e1lidos y casos borde.\n</code></pre> <ul> <li>M\u00f3dulo A</li> <li>Funci\u00f3n: <code>procesar()</code></li> <li>Entrada:<ul> <li><code>signal</code> (float)</li> <li><code>freq</code> (Hz)</li> </ul> </li> <li>Salida:<ul> <li>JSON con <code>valor</code>, <code>unidad</code></li> </ul> </li> <li> <p>Note</p> <pre><code>Documenta rangos v\u00e1lidos y casos borde.\n</code></pre> </li> </ul>"},{"location":"comandos/#bloques-de-cita-con-codigo-pseudo-logs","title":"Bloques de cita con c\u00f3digo (pseudo-logs)","text":"<pre><code>&gt; **Log:**\n&gt; ```\n&gt; [12:00:00] Init OK\n&gt; [12:00:01] Conectando a I2C...\n&gt; [12:00:02] Lectura: 523 mV\n&gt; ```\n</code></pre> <p>Log: <pre><code>[12:00:00] Init OK\n[12:00:01] Conectando a I2C...\n[12:00:02] Lectura: 523 mV\n</code></pre></p>"},{"location":"ejemplo/","title":"\ud83d\udcda Ejemplo de Documentaci\u00f3n del Proyecto","text":"<p>Plantilla gen\u00e9rica para documentar proyectos acad\u00e9micos o de ingenier\u00eda. Copia y adapta las secciones seg\u00fan tu necesidad.</p>"},{"location":"ejemplo/#1-resumen","title":"1) Resumen","text":"<ul> <li>Nombre del proyecto: Mi Proyecto </li> <li>Equipo / Autor(es): Nombre(s) </li> <li>Curso / Asignatura: Nombre del curso </li> <li>Fecha: DD/MM/AAAA </li> <li>Descripci\u00f3n breve: Una o dos l\u00edneas que expliquen qu\u00e9 hace y por qu\u00e9.</li> </ul> <p>Consejo</p> <p>Mant\u00e9n este resumen corto (m\u00e1x. 5 l\u00edneas). Lo dem\u00e1s va en secciones espec\u00edficas.</p>"},{"location":"ejemplo/#2-objetivos","title":"2) Objetivos","text":"<ul> <li>General: Qu\u00e9 se pretende lograr en t\u00e9rminos amplios.</li> <li>Espec\u00edficos:</li> <li>OE1\u2026</li> <li>OE2\u2026</li> <li>OE3\u2026</li> </ul>"},{"location":"ejemplo/#3-alcance-y-exclusiones","title":"3) Alcance y Exclusiones","text":"<ul> <li>Incluye: Qu\u00e9 funcionalidades/entregables s\u00ed est\u00e1n en el proyecto.</li> <li>No incluye: Qu\u00e9 queda fuera para evitar malentendidos.</li> </ul>"},{"location":"ejemplo/#4-requisitos","title":"4) Requisitos","text":"<p>Software - SO compatible (Windows/Linux/macOS) - Python 3.x / Node 18+ / Arduino IDE / etc. - Dependencias (p. ej., pip/requirements, npm packages)</p> <p>Hardware (si aplica) - MCU / Sensores / Actuadores / Fuente de poder - Herramientas (mult\u00edmetro, caut\u00edn, etc.)</p> <p>Conocimientos previos - Programaci\u00f3n b\u00e1sica en X - Electr\u00f3nica b\u00e1sica - Git/GitHub</p>"},{"location":"ejemplo/#5-instalacion","title":"5) Instalaci\u00f3n","text":"<pre><code># 1) Clonar\ngit clone https://github.com/&lt;usuario&gt;/&lt;repo&gt;.git\ncd &lt;repo&gt;\n\n# 2) (Opcional) Crear entorno virtual\npython -m venv .venv\n# macOS/Linux\nsource .venv/bin/activate\n# Windows (PowerShell)\n.venv\\Scripts\\Activate.ps1\n\n# 3) Instalar dependencias (ejemplos)\npip install -r requirements.txt\n# o, si es Node:\nnpm install\n</code></pre>"},{"location":"gitcmds/","title":"\ud83d\ude80 Comandos b\u00e1sicos de Git (primeros pasos)","text":"<p>En este curso solo usaremos los comandos esenciales de Git para trabajar con repositorios.</p>"},{"location":"gitcmds/#1-clonar-un-repositorio","title":"1. Clonar un repositorio","text":"<p>Copia un proyecto de GitHub a tu computadora.</p> <pre><code>git clone https://github.com/usuario/repositorio.git\n</code></pre>"},{"location":"gitcmds/#2-verificar-cambios","title":"2. Verificar cambios","text":"<p>Muestra qu\u00e9 archivos has modificado o agregado.</p> <pre><code>git status\n</code></pre>"},{"location":"gitcmds/#3-preparar-cambios","title":"3. Preparar cambios","text":"<p>Agrega archivos para guardarlos en el pr\u00f3ximo commit.</p> <pre><code>git add archivo.txt\ngit add .   # agrega todos los archivos modificados\n</code></pre>"},{"location":"gitcmds/#4-guardar-cambios-commit","title":"4. Guardar cambios (commit)","text":"<p>Guarda tus cambios con un mensaje descriptivo.</p> <pre><code>git commit -m \"Descripci\u00f3n breve de los cambios\"\n</code></pre>"},{"location":"gitcmds/#5-subir-cambios-al-repositorio-push","title":"5. Subir cambios al repositorio (push)","text":"<p>Env\u00eda tus commits locales al repositorio en GitHub.</p> <pre><code>git push origin main\n</code></pre>"},{"location":"gitcmds/#6-traer-cambios-del-remoto-pull","title":"6. Traer cambios del remoto (pull)","text":"<p>Actualiza tu proyecto con los \u00faltimos cambios de GitHub.</p> <pre><code>git pull origin main\n</code></pre>"},{"location":"gitcmds/#flujo-tipico-de-trabajo","title":"Flujo t\u00edpico de trabajo","text":"<ol> <li> <p>Traer cambios del remoto <pre><code>git pull origin main\n</code></pre></p> </li> <li> <p>Editar tus archivos de proyecto.</p> </li> <li> <p>Preparar los cambios <pre><code>git add .\n</code></pre></p> </li> <li> <p>Guardar los cambios <pre><code>git commit -m \"Mensaje descriptivo\"\n</code></pre></p> </li> <li> <p>Enviar los cambios al remoto <pre><code>git push origin main\n</code></pre></p> </li> </ol> <p>Consejo</p> <p>Piensa en este ciclo como un loop infinito: cada vez que quieras contribuir \u2192 primero <code>pull</code>, despu\u00e9s <code>add</code> + <code>commit</code>, y finalmente <code>push</code>.</p>"},{"location":"Homework/Activity%2001%20-%20ROS2%20Topics/","title":"ROS2 TOPICS","text":""},{"location":"Homework/Activity%2001%20-%20ROS2%20Topics/#introduction","title":"Introduction","text":"<p>In this activity, I work with ROS2 topics to understand how nodes communicate through publishers and subscribers. I create two nodes from scratch: one that publishes a constant integer value, and another that subscribes to this value, processes it, and publishes an accumulated result. By the end of the activity, I visualize the node\u2013topic graph and verify the data flow using ROS2 command-line tools.</p>"},{"location":"Homework/Activity%2001%20-%20ROS2%20Topics/#publisher-code","title":"Publisher Code","text":"<pre><code>#!/usr/bin/env python3\n\nimport rclpy\nfrom rclpy.node import Node\nfrom example_interfaces.msg import Int64\n\n\nclass NumberPublisher(Node):\n\n    def __init__(self):\n        super().__init__('publisher')\n        self.publisher_ = self.create_publisher(Int64,'/number',10)\n        self.timer = self.create_timer(1.0, self.timer_callback)\n        self.number = 50\n        self.get_logger().info('Publisher working...')\n\n    def timer_callback(self):\n        msg = Int64()\n        msg.data = self.number\n        self.publisher_.publish(msg)\n        self.get_logger().info(f'Publicando: {msg.data}')\n\ndef main(args=None):\n    rclpy.init(args=args)\n    nodito = NumberPublisher()\n    rclpy.spin(nodito)\n    rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n</code></pre> <p>The NumberPublisher node creates a publisher on the /number topic using the Int64 message type and uses a timer to send the value 50 once every second. Each time the timer callback is executed, a message is created, populated with the number, and published, while also printing a log message to confirm the data being sent. The main function initializes ROS2, runs the node, and keeps it active until it is manually stopped.</p>"},{"location":"Homework/Activity%2001%20-%20ROS2%20Topics/#publisher-and-suscriber-code","title":"Publisher and Suscriber Code","text":"<pre><code>#!/usr/bin/env python3\n\nimport rclpy\nfrom rclpy.node import Node\nfrom example_interfaces.msg import Int64\n\n\nclass NumberCounter(Node):\n\n    def __init__(self):\n        super().__init__('number_counter')\n        self.counter = 0\n        self.subscription = self.create_subscription(\n            Int64,\n            '/number',\n            self.listener_callback,\n            10\n        )\n        self.publisher_ = self.create_publisher(\n            Int64,\n            '/number_count',\n            10\n        )\n        self.get_logger().info('Number counter working...')\n\n    def listener_callback(self, msg):\n        self.counter += msg.data\n        out_msg = Int64()\n        out_msg.data = self.counter\n        self.publisher_.publish(out_msg)\n        self.get_logger().info(\n            f'Recibido: {msg.data} | Total: {self.counter}'\n        )\n\ndef main(args=None):\n    rclpy.init(args=args)\n    nodito = NumberCounter()\n    rclpy.spin(nodito)\n    rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n</code></pre> <p>This code defines a ROS2 node that subscribes to an integer topic, processes incoming data, and publishes the accumulated result. The NumberCounter node listens to the /number topic using the Int64 message type and maintains an internal counter that increases every time a new value is received. Inside the subscriber callback, the received number is added to the counter, and the updated total is immediately published to the /number_count topic</p>"},{"location":"Homework/Activity%2001%20-%20ROS2%20Topics/#conclution","title":"Conclution","text":"<p>Through this activity, I successfully implemented ROS2 communication using topics by creating interacting publisher and subscriber nodes. The system demonstrates how data can be generated, processed, and redistributed in real time, reinforcing the fundamental ROS2 concepts of node interaction, message passing, and callback-based execution.</p> <p></p>"},{"location":"Homework/Activity%20ROS2%20Services/","title":"Activity - ROS 2 Services","text":""},{"location":"Homework/Activity%20ROS2%20Services/#introduction","title":"Introduction","text":"<p>In distributed systems developed with ROS 2, communication between nodes can be achieved through different mechanisms, with topics and services being two of the most fundamental. While topics enable continuous, asynchronous communication based on the publisher\u2013subscriber model, services introduce a synchronous request\u2013response interaction.</p> <p>This activity focuses on deepening the understanding of ROS 2 services within an existing topic-based system. Starting from a node that publishes numbers and another that accumulates them into a counter, a new capability is introduced: resetting the accumulated value through a service call. This approach highlights how on-demand interactions can be integrated into a distributed architecture, reinforcing modular design and controlled system behavior.</p>"},{"location":"Homework/Activity%20ROS2%20Services/#publisher-code","title":"Publisher Code","text":"<p><pre><code>#!/usr/bin/env python3\n\nimport rclpy\nfrom rclpy.node import Node\nfrom example_interfaces.msg import Int64\n\n\nclass NumberCounter(Node):\n\n    def __init__(self):\n        super().__init__('number_counter')\n        self.counter = 0\n        self.subscription = self.create_subscription(\n            Int64,\n            '/number',\n            self.listener_callback,\n            10\n        )\n        self.publisher_ = self.create_publisher(\n            Int64,\n            '/number_count',\n            10\n        )\n        self.get_logger().info('Number counter working...')\n\n    def listener_callback(self, msg):\n        self.counter += msg.data\n        out_msg = Int64()\n        out_msg.data = self.counter\n        self.publisher_.publish(out_msg)\n        self.get_logger().info(\n            f'Recibido: {msg.data} | Total: {self.counter}'\n        )\n\ndef main(args=None):\n    rclpy.init(args=args)\n    nodito = NumberCounter()\n    rclpy.spin(nodito)\n    rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n</code></pre> This code implements a node named number_counter, whose primary function is to receive numerical values, accumulate them, and publish the updated result.</p> <p>The node subscribes to the /number topic, where it receives messages of type Int64. Each time a new message arrives, the listener_callback method is automatically triggered, adding the received value to an internal variable that acts as an accumulative counter. The updated total is then published on the /number_count topic, making the information available to other nodes in the system.</p>"},{"location":"Homework/Activity%20ROS2%20Services/#suscriber-code","title":"Suscriber Code","text":"<p><pre><code>#!/usr/bin/env python3\n\nimport rclpy\nfrom rclpy.node import Node\nfrom example_interfaces.msg import Int64\nfrom example_interfaces.srv import SetBool\n\n\nclass NumberCounter(Node):\n    def __init__(self):\n        super().__init__('number_counter')\n        self.counter = 0\n        self.subscription = self.create_subscription(\n            Int64,\n            '/number',\n            self.listener_callback,\n            10\n        )\n        self.publisher_ = self.create_publisher(\n            Int64,\n            '/number_count',\n            10\n        )\n        self.service = self.create_service(\n            SetBool,\n            '/reset_counter',\n            self.reset_callback\n        )\n        self.get_logger().info('Number counter working...')\n\n    def listener_callback(self, msg):\n        self.counter += msg.data\n        out_msg = Int64()\n        out_msg.data = self.counter\n        self.publisher_.publish(out_msg)\n        self.get_logger().info(\n            f'Recibido: {msg.data} | Total: {self.counter}'\n        )\n\n    def reset_callback(self, request, response):\n        if request.data:\n            self.counter = 0\n            response.success = True\n            response.message = \"Counter reset to zero\"\n            self.get_logger().info(\"Counter has been reset!\")\n        else:\n            response.success = False\n            response.message = \"Reset not requested\"\n        return response\n\n\ndef main(args=None):\n    rclpy.init(args=args)\n    nodito = NumberCounter()\n    rclpy.spin(nodito)\n    rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n</code></pre> This code implements a node named number_counter that integrates both the publisher\u2013subscriber model and the client\u2013server model through services.</p> <p>On one hand, the node subscribes to the /number topic, receiving Int64 messages. Each time a new value arrives, the listener_callback method is automatically triggered, adding the received data to an internal accumulative counter. The updated total is then published on the /number_count topic, maintaining a continuous reactive processing flow.</p> <p>On the other hand, the node includes a service server named /reset_counter, using the SetBool service type. Through the reset_callback method, external requests can directly modify the node\u2019s internal state. If the request contains a true boolean value, the counter is reset to zero and a confirmation response is returned. If the value is false, the state remains unchanged and the response indicates that no reset was performed.</p>"},{"location":"Homework/Activity%20ROS2%20Services/#results","title":"Results","text":"<p>In the following image you can see the code working in the terminals, one is sending a message, the other one is reciving the message sent by the other terminal and the last one resets the counter to zero.</p> <p></p> <p></p>"},{"location":"Homework/Activiy%20ROS%20Custom%20Interfaces/","title":"Activiy ROS Custom Interfaces","text":""},{"location":"Homework/Activiy%20ROS%20Custom%20Interfaces/#introduction","title":"Introduction","text":"<p>In this activity, a distributed system was developed in ROS 2 to simulate the interaction between a battery and an LED panel using custom interfaces. The main objective was to implement communication between nodes through a user-defined service and a custom message. In the following image you can see the diagram of how it should work:</p> <p>Diagrama del sistema</p>"},{"location":"Homework/Activiy%20ROS%20Custom%20Interfaces/#battery-code","title":"Battery code","text":"<pre><code>#!/usr/bin/env python3\n\nimport rclpy\nfrom rclpy.node import Node\nfrom secondinterface.srv import SetLed\n\nclass BatteryNode(Node):\n    def __init__(self):\n        super().__init__('battery_node')\n        self.client = self.create_client(SetLed, 'set_led')\n\n        while not self.client.wait_for_service(timeout_sec=1.0):\n            self.get_logger().info('Waiting for set_led service...')\n\n        self.battery_level = 100\n        self.discharging = True  \n        self.timer = self.create_timer(1.0, self.update_battery)\n        self.get_logger().info(\"Battery simulation started\")\n\n    def update_battery(self):\n        if self.discharging:\n            self.battery_level -= 10\n        else:\n            self.battery_level += 10\n\n        self.print_battery_bar()\n\n        if self.battery_level &lt;= 0:\n            self.battery_level = 0\n            self.get_logger().info(\"Battery EMPTY \u2192 Turning LED ON\")\n            self.send_request(0, True)\n            self.discharging = False\n\n        elif self.battery_level &gt;= 100:\n            self.battery_level = 100\n            self.get_logger().info(\"Battery FULL \u2192 Turning LED OFF\")\n            self.send_request(0, False)\n            self.discharging = True\n\n    def print_battery_bar(self):\n        bars = int(self.battery_level / 10)\n        bar_display = \"[\" + \"-\" * bars + \" \" * (10 - bars) + \"]\"\n        self.get_logger().info(f\"Battery: {bar_display} {self.battery_level}%\")\n\n    def send_request(self, index, state):\n        request = SetLed.Request()\n        request.led_index = index\n        request.state = state\n        self.client.call_async(request)\n\ndef main(args=None):\n    rclpy.init(args=args)\n    node = BatteryNode()\n    rclpy.spin(node)\n    rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n</code></pre> <p>This code implements a node named battery_node, whose function is to simulate the behavior of a battery. It initializes the battery level at 100% and uses a timer that executes every second to decrease or increase the level in 10-unit intervals depending on the current state. </p> <p>When the level reaches 0%, the node sends a request to the service to turn on an LED and switches to charging mode. When it reaches 100%, it sends another request to turn the LED off and returns to discharging mode.</p>"},{"location":"Homework/Activiy%20ROS%20Custom%20Interfaces/#led-code","title":"LED code","text":"<pre><code>#!/usr/bin/env python3\n\nimport rclpy\nfrom rclpy.node import Node\nfrom secondinterface.msg import LedPanelState\nfrom secondinterface.srv import SetLed\n\nclass LedPanelNode(Node):\n    def __init__(self):\n        super().__init__('led_panel_node')\n        self.leds = [0, 0, 0]\n        self.publisher = self.create_publisher(LedPanelState,'led_panel_state',10)\n        self.service = self.create_service(SetLed,'set_led',self.set_led_callback)\n        self.timer = self.create_timer(1.0, self.publish_status)\n        self.get_logger().info(\"LED Panel Node Started\")\n\n    def publish_status(self):\n        msg = LedPanelState()\n        msg.leds = self.leds\n        self.publisher.publish(msg)\n\n    def set_led_callback(self, request, response):\n        if 0 &lt;= request.led_index&lt;len(self.leds):\n            self.leds[request.led_index] = 1 if request.state else 0\n            response.success = True\n            response.message = \"LED updated\"\n        else:\n            response.success = False\n            response.message = \"Invalid index\"\n        return response\n\ndef main(args=None):\n    rclpy.init(args=args)\n    node = LedPanelNode()\n    rclpy.spin(node)\n    rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n</code></pre> <p>This code implements a node named led_panel_node, whose purpose is to manage the state of a three-LED panel using custom interfaces. The node initializes an array representing the on/off state and periodically publishes this state topic using a custom message, and simultaneously operates as a server.  Through this service, it receives requests specifying which LED should change state and whether it should be turned on or off and responds indicating whether the operation was successful.</p>"},{"location":"Homework/Activiy%20ROS%20Custom%20Interfaces/#results","title":"Results","text":""},{"location":"Homework/Forward%20Kinematics%20for%20KUKA%20AN%20UR%20ROBOT/","title":"Forward Kinematics for KUKA AN UR ROBOT","text":""},{"location":"Homework/Forward%20Kinematics%20for%20KUKA%20AN%20UR%20ROBOT/#introduction","title":"Introduction","text":"<p>In this activity, the kinematic modeling of two industrial manipulators will be developed: a KUKA robot and a UR robot. The Denavit\u2013Hartenberg (DH) convention will be used to mathematically describe the geometric relationships between links through standardized parameters.</p>"},{"location":"Homework/Forward%20Kinematics%20for%20KUKA%20AN%20UR%20ROBOT/#kuka","title":"KUKA","text":""},{"location":"Homework/Forward%20Kinematics%20for%20KUKA%20AN%20UR%20ROBOT/#schematic-diagram","title":"Schematic diagram","text":""},{"location":"Homework/Forward%20Kinematics%20for%20KUKA%20AN%20UR%20ROBOT/#d-h-table","title":"D-H Table","text":"Joint d \u03b8 a \u03b1 1 -935 \u03b81 260 \u03c0/2 2 0 \u03b82 -680 0 3 0 \u03b83 0 -\u03c0/2 4 -630 \u03b84 0 \u03c0/2 5 0 \u03b85 0 -\u03c0/2 6 -135 \u03b86 0 0"},{"location":"Homework/Forward%20Kinematics%20for%20KUKA%20AN%20UR%20ROBOT/#ur","title":"UR","text":""},{"location":"Homework/Forward%20Kinematics%20for%20KUKA%20AN%20UR%20ROBOT/#schematic-diagram_1","title":"Schematic diagram","text":""},{"location":"Homework/Forward%20Kinematics%20for%20KUKA%20AN%20UR%20ROBOT/#d-h-table_1","title":"D-H Table","text":"Joint d \u03b8 a \u03b1 1 162 \u03b81 + \u03c0/2 0 \u03c0/2 2 0 \u03b82  + \u03c0/2 425 0 3 0 \u03b83 392 0 4 133 \u03b84 -\u03c0/2 0 -\u03c0/2 5 100 \u03b85 0 \u03c0/2 6 42 \u03b86 + \u03c0/2 0 0"},{"location":"Homework/Forward%20Kinematics/","title":"Forward Kinematics","text":""},{"location":"Homework/Forward%20Kinematics/#introduction","title":"Introduction","text":"<p>Robotics kinematics studies robot motion without considering the forces involved, focusing on the position and orientation of its links. Forward kinematics computes the end-effector position and orientation from the joint variables. The robot is modeled as a kinematic chain of links and joints, using reference frames to describe spatial relationships. The Denavit\u2013Hartenberg convention standardizes this representation using four parameters, simplifying the kinematic analysis of robotic manipulators.</p>"},{"location":"Homework/Forward%20Kinematics/#exercices","title":"Exercices","text":""},{"location":"Homework/Forward%20Kinematics/#exercise-1","title":"Exercise 1","text":""},{"location":"Homework/Forward%20Kinematics/#exercise-2","title":"Exercise 2","text":""},{"location":"Homework/Forward%20Kinematics/#exercise-3","title":"Exercise 3","text":""},{"location":"Homework/Forward%20Kinematics/#exercise-4","title":"Exercise 4","text":""},{"location":"Homework/Forward%20Kinematics/#final-transformation-matrix","title":"Final Transformation Matrix","text":"<pre><code>T06 = [\n r11 r12 r13 px\n r21 r22 r23 py\n r31 r32 r33 pz\n 0   0   0   1\n]\n</code></pre>"},{"location":"Homework/Forward%20Kinematics/#rotation-terms","title":"Rotation Terms","text":"<pre><code>r11 = c1*c23*c4*s5 + c1*s23*c5 - s1*s4*s5\n\nr12 = c6*(c1*c23*s4 + s1*c4)\n      - s6*(c1*c23*c4*c5 - c1*s23*s5 - s1*s4*c5)\n\nr13 = s6*(c1*c23*s4 + s1*c4)\n      + c6*(c1*c23*c4*c5 - c1*s23*s5 - s1*s4*c5)\n\nr21 = s1*c23*c4*s5 + s1*s23*c5 + c1*s4*s5\n\nr22 = c6*(s1*c23*s4 - c1*c4)\n      - s6*(s1*c23*c4*c5 - s1*s23*s5 + c1*s4*c5)\n\nr23 = s6*(s1*c23*s4 - c1*c4)\n      + c6*(s1*c23*c4*c5 - s1*s23*s5 + c1*s4*c5)\n\nr31 = s23*c4*s5 - c23*c5\n\nr32 = c6*s23*s4\n      - s6*(s23*c4*c5 + c23*s5)\n\nr33 = s6*s23*s4\n      + c6*(s23*c4*c5 + c23*s5)\n</code></pre>"},{"location":"Homework/Forward%20Kinematics/#position-terms","title":"Position Terms","text":"<pre><code>px = c1*(8*c2 + 8*c23 - d4*s23) - d3*s1\n\npy = s1*(8*c2 + 8*c23 - d4*s23) + d3*c1\n\npz = 13 + 8*s2 + 8*s23 + d4*c23 + d6\n</code></pre>"},{"location":"Homework/Forward%20Kinematics/#exercise-5","title":"Exercise 5","text":""},{"location":"Homework/Ros%20Basics%20Capstone/","title":"Ros2 Turtle Catcher","text":"<p>Hector Cornejo Morales Augusto Mantilla Molina</p> <p>Activity: The objective of this assignment is to design a reactive control system in ROS2 using the turtlesim simulator.</p> <p>The sistem consist of - A spawner node that continuously creates turtles and publishes their information. - A controller node that:     - Monitors the position of turtle1     - Receives a list of alive turtles     - Computes which turtle is the closest     - Moves turtle1 toward the nearest turtle     - Calls a service to remove (catch) the turtle when it reaches it The controller implements a proportional control strategy to guide turtle1 toward the nearest target at all times.</p>"},{"location":"Homework/Ros%20Basics%20Capstone/#1-turtle-controller","title":"1) Turtle Controller","text":""},{"location":"Homework/Ros%20Basics%20Capstone/#controller-implementation","title":"Controller Implementation","text":""},{"location":"Homework/Ros%20Basics%20Capstone/#libraries","title":"Libraries","text":"<p><pre><code>#!/usr/bin/env python3\n\nimport rclpy\nfrom rclpy.node import Node\nfrom geometry_msgs.msg import Twist\nfrom turtlesim.msg import Pose\nimport math\nimport numpy as np\nfrom turtle_catcher_interfaces.msg import TurtleArray\nfrom turtle_catcher_interfaces.srv import CatchTurtle \n</code></pre> What does it do? - rclpy \u2192 ROS2 Python client library  - Node \u2192 Base class for creating ROS2 nodes - Twist \u2192 Message used to control turtle velocity - Pose \u2192 Message that provides turtle position and orientation - math and numpy \u2192 Used for geometric calculations - TurtleArray \u2192 Custom message that contains all alive turtles - CatchTurtle \u2192 Custom service used to remove a turtle</p>"},{"location":"Homework/Ros%20Basics%20Capstone/#class-definition-and-constructor","title":"Class Definition and Constructor","text":"<pre><code>class Turtle_Controller(Node):\n\n    def __init__(self):\n        super().__init__('turtle_controller')\n\n        self.cmd_publisher = self.create_publisher(Twist, \"turtle1/cmd_vel\", 10)\n        self.pose_sub = self.create_subscription(Pose, \"turtle1/pose\", self.pose_callback, 10)\n        self.alive_sub = self.create_subscription(TurtleArray, \"alive_turtles\", self.alive_turtles_callback, 10)\n\n        self.catch_client = self.create_client(CatchTurtle, \"catch_turtle\")\n\n        while not self.catch_client.wait_for_service(timeout_sec=1.0):\n            self.get_logger().info(\"Waiting for catch_turtle service...\")\n\n        self.timer = self.create_timer(0.01, self.control_loop)\n\n        self.current_pose = None\n        self.target_turtle = []\n\n        self.Kp_d = 1.5\n        self.Kp_theta = 6.0\n\n        self.get_logger().info(\"Your Turtlesim Controller is operational\")\n</code></pre> <p>What does it do? - Initializes the node with the name turtle_controller  - Creates     - A publisher to control turtle1     - A subscriber to read the pose of turtle1     - A subscriber to receive all alive turtles - Creates a service client to request turtle removal - Waits until the catch_turtle service is available - Creates a timer that executes the control loop every 0.01 seconds - Defines proportional gains for:  - Distance control (Kp_d)  - Orientation control (Kp_theta)</p>"},{"location":"Homework/Ros%20Basics%20Capstone/#pose-callback","title":"Pose Callback","text":"<p><pre><code>def pose_callback(self, msg):\n    self.current_pose = msg\n</code></pre> What does it do? - Stores the current position and orientation of turtle1  - This data is later used for distance and angle calculations </p>"},{"location":"Homework/Ros%20Basics%20Capstone/#alive-turtle-callback","title":"Alive Turtle Callback","text":"<p><pre><code>def alive_turtles_callback(self, msg):\n    self.target_turtle = msg.turtles\n</code></pre> What does it do? - Receives the list of currently alive turtles - Stores them in self.target_turtle - This list is used to determine which turtle is closest</p>"},{"location":"Homework/Ros%20Basics%20Capstone/#control-loop","title":"Control Loop","text":"<p><pre><code>def control_loop(self):\n\n    if self.current_pose is None or len(self.target_turtle) == 0:\n        return\n\n    min_distance = float('inf')\n    nearest_turtle = None\n\n    for turtle in self.target_turtle:\n        dx = turtle.x - self.current_pose.x\n        dy = turtle.y - self.current_pose.y\n        distance = math.sqrt(dx**2 + dy**2)\n        if distance &lt; min_distance:\n            min_distance = distance\n            nearest_turtle = turtle\n\n    if nearest_turtle is None:\n        return\n\n    dx = nearest_turtle.x - self.current_pose.x\n    dy = nearest_turtle.y - self.current_pose.y\n\n    distance = math.sqrt(dx**2 + dy**2)\n\n    theta_target = math.atan2(dy, dx)\n    angle_error = theta_target - self.current_pose.theta\n    angle_error = (angle_error + np.pi) % (2 * np.pi) - np.pi\n\n    cmd = Twist()\n\n    if distance &lt; 0.3:\n\n        request = CatchTurtle.Request()\n        request.name = nearest_turtle.name\n        self.catch_client.call_async(request)\n\n        self.get_logger().info(f\"Capturando {nearest_turtle.name}\")\n\n        cmd.linear.x = 0.0\n        cmd.angular.z = 0.0\n\n    else:\n        cmd.linear.x = self.Kp_d * distance\n        cmd.angular.z = self.Kp_theta * angle_error\n\n    self.cmd_publisher.publish(cmd)\n</code></pre> What does it do? - Verifies that pose and turtle data are available. - Computes the distance to each turtle.  - Selects the turtle with the smallest distance. - Calculates:     - Distance to the target     - Desired heading angle     - Angular error - Applies proportional control to generate velocity commands. - If the turtle is close enough (distance &lt; 0.3):     - Calls the service to remove it.     - Stops movement.</p>"},{"location":"Homework/Ros%20Basics%20Capstone/#control-operation","title":"Control Operation","text":"<p>The controller uses a Proportional (P) control strategy to make a proportional control for the linear and angular velocitys. The angle error is normalized between \u2212\u03c0 and \ud835\udf0b to ensure smooth rotation. This creates a reactive pursuit behavior where turtle1 always moves toward the nearest turtle.</p>"},{"location":"Homework/Ros%20Basics%20Capstone/#full-controller-code","title":"Full Controller Code","text":"<pre><code>#!/usr/bin/env python3\n\n# ROS2 Python client library\nimport rclpy\nfrom rclpy.node import Node\n\n# Message used to control turtle velocity\nfrom geometry_msgs.msg import Twist\n\n# Message that provides turtle position and orientation\nfrom turtlesim.msg import Pose\n\n# Math libraries for distance and angle calculations\nimport math\nimport numpy as np\n\n# Custom message containing a list of alive turtles\nfrom turtle_catcher_interfaces.msg import TurtleArray\n\n# Custom service used to remove a turtle\nfrom turtle_catcher_interfaces.srv import CatchTurtle \n\n\nclass Turtle_Controller(Node):\n    \"\"\"\n    Controller node that moves turtle1 toward the nearest turtle\n    and requests its removal once it is close enough.\n    \"\"\"\n\n    def __init__(self):\n        # Initialize the node with the name 'turtle_controller'\n        super().__init__('turtle_controller')\n\n        # Publisher that sends velocity commands to turtle1\n        self.cmd_publisher = self.create_publisher(\n            Twist, \"turtle1/cmd_vel\", 10\n        )\n\n        # Subscriber that receives the pose of turtle1\n        self.pose_sub = self.create_subscription(\n            Pose, \"turtle1/pose\", self.pose_callback, 10\n        )\n\n        # Subscriber that receives the list of all alive turtles\n        self.alive_sub = self.create_subscription(\n            TurtleArray, \"alive_turtles\", self.alive_turtles_callback, 10\n        )\n\n        # Service client used to request turtle removal\n        self.catch_client = self.create_client(\n            CatchTurtle, \"catch_turtle\"\n        )\n\n        # Wait until the service is available\n        while not self.catch_client.wait_for_service(timeout_sec=1.0):\n            self.get_logger().info(\"Waiting for catch_turtle service...\")\n\n        # Timer that executes the control loop at 100 Hz\n        self.timer = self.create_timer(0.01, self.control_loop)\n\n        # Stores the current pose of turtle1\n        self.current_pose = None\n\n        # Stores the list of alive turtles\n        self.target_turtle = []\n\n        # Proportional control gains\n        self.Kp_d = 1.5      # Distance gain\n        self.Kp_theta = 6.0  # Angular gain\n\n        self.get_logger().info(\"Your Turtlesim Controller is operational\")\n\n    def pose_callback(self, msg):\n        \"\"\"\n        Callback that stores the current pose of turtle1.\n        \"\"\"\n        self.current_pose = msg\n\n    def alive_turtles_callback(self, msg):\n        \"\"\"\n        Callback that receives and stores all alive turtles.\n        \"\"\"\n        self.target_turtle = msg.turtles\n\n    def control_loop(self):\n        \"\"\"\n        Main control loop:\n        - Finds the nearest turtle\n        - Moves turtle1 toward it\n        - Calls the service to remove it when close enough\n        \"\"\"\n\n        # Exit if pose data or turtle list is not available\n        if self.current_pose is None or len(self.target_turtle) == 0:\n            return\n\n        # Variables used to find the nearest turtle\n        min_distance = float('inf')\n        nearest_turtle = None\n\n        # Iterate through all turtles to find the closest one\n        for turtle in self.target_turtle:\n            dx = turtle.x - self.current_pose.x\n            dy = turtle.y - self.current_pose.y\n            distance = math.sqrt(dx**2 + dy**2)\n\n            if distance &lt; min_distance:\n                min_distance = distance\n                nearest_turtle = turtle\n\n        # Safety check\n        if nearest_turtle is None:\n            return\n\n        # Compute distance and direction to the nearest turtle\n        dx = nearest_turtle.x - self.current_pose.x\n        dy = nearest_turtle.y - self.current_pose.y\n        distance = math.sqrt(dx**2 + dy**2)\n\n        # Desired heading angle\n        theta_target = math.atan2(dy, dx)\n\n        # Angular error between current and desired orientation\n        angle_error = theta_target - self.current_pose.theta\n\n        # Normalize angle error to [-pi, pi]\n        angle_error = (angle_error + np.pi) % (2 * np.pi) - np.pi\n\n        # Create velocity command message\n        cmd = Twist()\n\n        # If turtle is close enough, request removal\n        if distance &lt; 0.3:\n\n            request = CatchTurtle.Request()\n            request.name = nearest_turtle.name\n            self.catch_client.call_async(request)\n\n            self.get_logger().info(f\"Capturando {nearest_turtle.name}\")\n\n            # Stop movement after catching\n            cmd.linear.x = 0.0\n            cmd.angular.z = 0.0\n\n        else:\n            # Proportional control for movement\n            cmd.linear.x = self.Kp_d * distance\n            cmd.angular.z = self.Kp_theta * angle_error\n\n        # Publish velocity command\n        self.cmd_publisher.publish(cmd)\n\n\ndef main(args=None):\n    # Initialize ROS2\n    rclpy.init(args=args)\n\n    # Create controller node\n    node = Turtle_Controller()\n\n    # Keep the node running\n    rclpy.spin(node)\n\n    # Shutdown ROS2\n    rclpy.shutdown()\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"Homework/Ros%20Basics%20Capstone/#2-turtle-spawner","title":"2) Turtle Spawner","text":""},{"location":"Homework/Ros%20Basics%20Capstone/#requiers-libraries","title":"Requiers Libraries","text":"<p><pre><code>import rclpy\nfrom rclpy.node import Node\nimport random\nfrom turtlesim.srv import Spawn\nfrom turtlesim.srv import Kill\nfrom turtle_catcher_interfaces.msg import Turtle\nfrom turtle_catcher_interfaces.msg import TurtleArray\nfrom turtle_catcher_interfaces.srv import CatchTurtle\n</code></pre> What does it do? - Spawn \u2192 Built-in turtlesim service to create turtles  - Kill \u2192 Built-in turtlesim service to remove turtles - Turtle \u2192 Custom message for a single turtl - TurtleArray \u2192 Custom message for multiple turtles - CatchTurtle \u2192 Custom service used by the controller</p>"},{"location":"Homework/Ros%20Basics%20Capstone/#class-definition-and-initialization","title":"Class Definition and Initialization","text":"<p><pre><code>class TurtleSpawner(Node):\n</code></pre> This class defines the spawner node.</p>"},{"location":"Homework/Ros%20Basics%20Capstone/#full-spawner-code","title":"Full Spawner Code","text":"<pre><code>#!/usr/bin/env python3\n\n# ROS2 Python client library\nimport rclpy\nfrom rclpy.node import Node\n\n# Used to generate random spawn positions\nimport random\n\n# Built-in turtlesim services\nfrom turtlesim.srv import Spawn\nfrom turtlesim.srv import Kill\n\n# Custom messages\nfrom turtle_catcher_interfaces.msg import Turtle\nfrom turtle_catcher_interfaces.msg import TurtleArray\n\n# Custom service used by the controller to request turtle removal\nfrom turtle_catcher_interfaces.srv import CatchTurtle\n\n\nclass TurtleSpawner(Node):\n    \"\"\"\n    This node is responsible for:\n    - Spawning turtles at random positions\n    - Keeping track of all alive turtles\n    - Publishing the list of alive turtles\n    - Providing a service to remove turtles when captured\n    \"\"\"\n\n    def __init__(self):\n        # Initialize the node with name 'turtle_spawner'\n        super().__init__('turtle_spawner')\n\n        # Client to call the turtlesim spawn service\n        self.spawn_client = self.create_client(Spawn, '/spawn')\n\n        # Client to call the turtlesim kill service\n        self.kill_client = self.create_client(Kill, '/kill')\n\n        # Service server that allows the controller to request turtle removal\n        self.catch_service = self.create_service(\n            CatchTurtle,\n            '/catch_turtle',\n            self.catch_callback\n        )\n\n        # Publisher that sends the list of alive turtles\n        self.alive_publisher = self.create_publisher(\n            TurtleArray,\n            '/alive_turtles',\n            10\n        )\n\n        # Internal list that stores all currently alive turtles\n        self.alive_turtles = []\n\n        # Counter used to generate unique turtle names\n        self.turtle_counter = 0\n\n        # Timer that spawns a turtle every 0.5 seconds\n        self.spawn_timer = self.create_timer(0.5, self.spawn_turtle)\n\n        self.get_logger().info(\"Turtle Spawner iniciado\")\n\n    def spawn_turtle(self):\n        \"\"\"\n        Periodically spawns a new turtle at a random position.\n        \"\"\"\n\n        # Check if the spawn service is available\n        if not self.spawn_client.wait_for_service(timeout_sec=1.0):\n            self.get_logger().warning(\"Spawn service no disponible\")\n            return\n\n        # Generate random coordinates inside valid turtlesim area\n        x = random.uniform(1.0, 10.0)\n        y = random.uniform(1.0, 10.0)\n\n        # Create spawn request\n        request = Spawn.Request()\n        request.x = x\n        request.y = y\n        request.theta = 0.0\n        request.name = f\"enemy_{self.turtle_counter}\"\n\n        # Send asynchronous spawn request\n        future = self.spawn_client.call_async(request)\n\n        # Register callback to handle response\n        future.add_done_callback(\n            lambda future: self.spawn_callback(future, x, y)\n        )\n\n        # Increment counter for next turtle\n        self.turtle_counter += 1\n\n    def spawn_callback(self, future, x, y):\n        \"\"\"\n        Executed when the spawn service returns a response.\n        Adds the new turtle to the internal list and publishes it.\n        \"\"\"\n\n        try:\n            response = future.result()\n        except Exception as e:\n            self.get_logger().error(f\"Error en spawn: {e}\")\n            return\n\n        # Create custom Turtle message\n        new_turtle = Turtle()\n        new_turtle.x = x\n        new_turtle.y = y\n        new_turtle.theta = 0.0\n        new_turtle.name = response.name\n\n        # Add new turtle to alive list\n        self.alive_turtles.append(new_turtle)\n\n        # Publish updated list\n        self.publish_alive_turtles()\n\n        self.get_logger().info(f\"Spawned {response.name}\")\n\n    def publish_alive_turtles(self):\n        \"\"\"\n        Publishes the current list of alive turtles.\n        \"\"\"\n\n        msg = TurtleArray()\n        msg.turtles = self.alive_turtles\n        self.alive_publisher.publish(msg)\n\n    def catch_callback(self, request, response):\n        \"\"\"\n        Service callback executed when the controller requests\n        the removal of a turtle.\n        \"\"\"\n\n        turtle_name = request.name\n        self.get_logger().info(f\"Intentando eliminar {turtle_name}\")\n\n        # Check if kill service is available\n        if not self.kill_client.wait_for_service(timeout_sec=1.0):\n            self.get_logger().warning(\"Kill service no disponible\")\n            response.success = False\n            return response\n\n        # Create kill request\n        kill_request = Kill.Request()\n        kill_request.name = turtle_name\n\n        # Send asynchronous kill request\n        self.kill_client.call_async(kill_request)\n\n        # Remove turtle from internal list\n        self.alive_turtles = [\n            turtle for turtle in self.alive_turtles\n            if turtle.name != turtle_name\n        ]\n\n        # Publish updated list\n        self.publish_alive_turtles()\n\n        self.get_logger().info(f\"{turtle_name} eliminada\")\n\n        response.success = True\n        return response\n\n\ndef main(args=None):\n    # Initialize ROS2\n    rclpy.init(args=args)\n\n    # Create spawner node\n    node = TurtleSpawner()\n\n    # Keep node running\n    rclpy.spin(node)\n\n    # Shutdown ROS2\n    rclpy.shutdown()\n\n\nif __name__ == '__main__':\n    main()\n</code></pre>"},{"location":"Homework/Ros%20Basics%20Capstone/#results","title":"Results","text":""},{"location":"Homework/Transform%20Nomenclature/","title":"Transform Nomenclature","text":""},{"location":"Homework/Transform%20Nomenclature/#exercise-1","title":"Exercise 1","text":"<p>A vector P is rotated about the axis Ya by an angle of 45\u00b0, and then rotated about the axis Xa by an angle of 60\u00b0. Give the rotation matrix that performs these rotations in the indicated order.</p> <p>Solving for the rotations of the Ya axis we will have the following matrix:</p> <p></p> <p>And for the Xa axis rotation we got this matrix:</p> <p></p> <p>Since the rotation around the Ya\u200b axis occurs first, the total rotation matrix is given by: </p> <p>Carrying out the matrix multiplication, we obtain: </p>"},{"location":"Homework/Transform%20Nomenclature/#exercise-2","title":"Exercise 2","text":"<p>Reference frame B is rotated with respect to reference frame A by an angle of 30\u00b0 about the axis Xa. The translation of frame B with respect to frame A is given by [5 10 0] formulate the homogeneous transformation matrix</p> <p>The rotation of frame B with respect to frame A about the XA axis is expressed as:</p> <p></p> <p>The translation of frame B relative to frame A is given by:</p> <p></p> <p>The homogeneous transformation matrix TAB is constructed as: C</p> <p>Substituting the corresponding terms: </p>"},{"location":"Homework/Transform%20Nomenclature/#exercise-3","title":"Exercise 3","text":"<ul> <li>From the given image, obtain:<ul> <li>The value of ABT</li> <li>The value of ACT</li> </ul> </li> </ul> <p>From the diagram, the origin of frame B is displaced from the origin of frame A by a distance of 3 units along the Xa axis. Therefore, the translation vector is:</p> <p></p> <p>Looking at the image the orientation of the axes corresponds to a rotation of 180\u25e6 about the Za axis:</p> <p></p> <p>So, the homogeneous transformation matrix Tab is this:</p> <p></p> <p>The origin of frame C is obtained by moving 3 units along the XA axis and 2 units along the ZA axis:</p> <p></p> <p>From the diagram, frame C is rotated by 30\u25e6 about the ZA axis with respect to frame A. The rotation matrix is given by:</p> <p></p> <p>So, the homogeneous transformation matrix Tab is this: </p>"}]}